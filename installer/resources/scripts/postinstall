#!/bin/bash
#
# Gnosis VPN Post-Installation Script
#
# This script runs after the package payload is installed.
# It performs:
# - Configuration file generation (config.toml)
# - Backup of existing configuration (if present)
# - Final permission adjustments
# - Optional convenience symlinks
#
# Arguments:
#   $1: Full path to the installation package
#   $2: Full path to the installation destination (target volume)
#   $3: Mountpoint of the destination volume
#   $4: Root directory "/" for the current system
#
# Environment variables from Distribution.xml choices:
#   INSTALLER_CHOICE_NETWORK: "rotsee" or "dufour"

set -euo pipefail

# Source unified logging library
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/logging.sh"

# Setup logging
setup_logging "postinstall"

# Configuration
CONFIG_DIR="${2}/etc/gnosisvpn"
CONFIG_FILE="${CONFIG_DIR}/config.toml"
VERSION_FILE="${CONFIG_DIR}/version.txt"
TEMPLATE_DIR_BUNDLE="${SCRIPT_DIR}/../config-templates"
BIN_DIR="${2}/usr/local/bin"
NETWORK="${INSTALLER_CHOICE_NETWORK:-rotsee}"

# Get installer version from package (if available) or use current date
INSTALLER_VERSION="${INSTALLER_VERSION:-$(date +%Y%m%d-%H%M%S)}"
PACKAGE_PATH="$1"

# Extract version from package filename if available
if [[ "$PACKAGE_PATH" =~ GnosisVPN-Installer-([^/]+)\.pkg ]]; then
    INSTALLER_VERSION="${BASH_REMATCH[1]}"
fi

# Validate network selection (whitelist)
if [[ ! "$NETWORK" =~ ^(rotsee|dufour)$ ]]; then
    log_error "Invalid network selection: $NETWORK"
    log_info "Valid options: rotsee, dufour"
    exit 1
fi

log_info "Install package: $1"
log_info "Target volume: $2"
log_info "Binary directory: $BIN_DIR"
log_info "Configuration directory: $CONFIG_DIR"
log_info "Configuration file: $CONFIG_FILE"
log_info "Network: $NETWORK"

# Rollback mechanism
ROLLBACK_STEPS=()
ROLLBACK_ENABLED=true
PREV_CONFIG_FILE=""

# Rollback functions
rollback_restore_config() {
    if [[ -n "$PREV_CONFIG_FILE" ]] && [[ -f "$PREV_CONFIG_FILE" ]]; then
        log_info "Restoring previous configuration"
        mv -f "$PREV_CONFIG_FILE" "$CONFIG_FILE" || true
    fi
}

rollback_remove_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        log_info "Removing newly created configuration"
        rm -f "$CONFIG_FILE" || true
    fi
}

# Add a rollback step
add_rollback_step() {
    local step="$1"
    ROLLBACK_STEPS+=("$step")
    log_debug "Rollback: Registered step - $step"
}

# Execute rollback
execute_rollback() {
    if [[ "$ROLLBACK_ENABLED" != "true" ]]; then
        return 0
    fi

    log_section "ERROR: Installation failed, executing rollback"

    local steps="${#ROLLBACK_STEPS[@]}"
    if [[ $steps -eq 0 ]]; then
        log_warn "No rollback steps registered"
        return 0
    fi

    log_info "Rolling back $steps step(s)..."

    # Execute rollback steps in reverse order
    for ((i=${#ROLLBACK_STEPS[@]}-1; i>=0; i--)); do
        local step="${ROLLBACK_STEPS[$i]}"
        log_info "Rollback step $((steps - i))/$steps: $step"
        
        # Call the rollback function directly (no eval)
        if "$step"; then
            log_success "Rollback step completed"
        else
            log_warn "Rollback step failed (continuing anyway)"
        fi
    done

    log_section "Rollback completed"
}

# Set up trap for automatic rollback on error
trap 'execute_rollback' ERR EXIT

# Disable rollback after successful installation
disable_rollback() {
    ROLLBACK_ENABLED=false
    trap - ERR EXIT
}

# Check if previous installation exists
check_previous_installation() {
    log_info "Checking for previous installation..."
    
    local has_previous=false
    local previous_version=""
    
    # Check for version file
    if [[ -f "$VERSION_FILE" ]]; then
        previous_version=$(cat "$VERSION_FILE" 2>/dev/null || echo "unknown")
        log_info "Found previous installation version: $previous_version"
        has_previous=true
    fi
    
    # Check for existing binaries
    if [[ -f "$BIN_DIR/gnosis_vpn" ]] || [[ -f "$BIN_DIR/gnosis_vpn-ctl" ]]; then
        log_info "Found existing binaries in $BIN_DIR"
        has_previous=true
        
        if [[ -z "$previous_version" ]]; then
            previous_version="legacy"
            log_info "Legacy installation detected (no version file)"
        fi
    fi
    
    if [[ "$has_previous" == true ]]; then
        log_info "Previous installation detected (version: $previous_version)"
        echo "update"
    else
        log_info "No previous installation found"
        echo "fresh"
    fi
}

# Compare binary checksums to determine if update is needed
binary_needs_update() {
    local binary_name="$1"
    local old_path="$BIN_DIR/$binary_name"
    local new_path="$2" # Path to new binary in temporary location
    
    if [[ ! -f "$old_path" ]]; then
        log_info "$binary_name: No existing binary, update needed"
        return 0 # Update needed
    fi
    
    if [[ ! -f "$new_path" ]]; then
        log_warn "$binary_name: New binary not found at $new_path"
        return 1 # No update needed (or error)
    fi
    
    local old_checksum new_checksum
    old_checksum=$(shasum -a 256 "$old_path" 2>/dev/null | cut -d' ' -f1 || echo "")
    new_checksum=$(shasum -a 256 "$new_path" 2>/dev/null | cut -d' ' -f1 || echo "")
    
    if [[ "$old_checksum" == "$new_checksum" ]]; then
        log_info "$binary_name: Checksums match, no update needed"
        return 1 # No update needed
    else
        log_info "$binary_name: Checksums differ, update needed"
        log_debug "  Old: $old_checksum"
        log_debug "  New: $new_checksum"
        return 0 # Update needed
    fi
}

# Update binary if changed
update_binary_if_needed() {
    local binary_name="$1"
    local source_path="$2" # Source binary from package payload
    local target_path="$BIN_DIR/$binary_name"
    
    log_info "Checking if $binary_name needs update..."
    
    if binary_needs_update "$binary_name" "$source_path"; then
        log_info "Updating $binary_name..."
        
        # Backup existing binary
        if [[ -f "$target_path" ]]; then
            local backup_path="${target_path}.backup-$(date +%Y%m%d-%H%M%S)"
            cp "$target_path" "$backup_path"
            log_info "Created backup: $backup_path"
        fi
        
        # Copy new binary
        if cp "$source_path" "$target_path"; then
            chmod 755 "$target_path"
            chown root:wheel "$target_path" 2>/dev/null || true
            log_success "Updated $binary_name"
            return 0
        else
            log_error "Failed to update $binary_name"
            return 1
        fi
    else
        log_info "$binary_name is up to date, skipping"
        return 0
    fi
}

# Save current installation version
save_version_info() {
    log_info "Saving installation version: $INSTALLER_VERSION"
    
    mkdir -p "$CONFIG_DIR"
    echo "$INSTALLER_VERSION" > "$VERSION_FILE"
    chmod 644 "$VERSION_FILE"
    chown root:wheel "$VERSION_FILE" 2>/dev/null || true
    
    log_success "Version saved to $VERSION_FILE"
}

# Cleanup old backup files (keep only the 5 most recent)
cleanup_old_backups() {
    log_info "Cleaning up old backup files..."
    
    # Clean up old config backups
    if ls "$CONFIG_DIR"/*.backup 2>/dev/null | head -1 >/dev/null; then
        local config_backups
        config_backups=$(ls -t "$CONFIG_DIR"/*.backup 2>/dev/null | tail -n +6)
        if [[ -n "$config_backups" ]]; then
            echo "$config_backups" | xargs rm -f
            local removed_count
            removed_count=$(echo "$config_backups" | wc -l | tr -d ' ')
            log_info "Removed $removed_count old configuration backup(s)"
        fi
    fi
    
    # Clean up old binary backups
    if ls "$BIN_DIR"/*.backup-* 2>/dev/null | head -1 >/dev/null; then
        local binary_backups
        binary_backups=$(ls -t "$BIN_DIR"/*.backup-* 2>/dev/null | tail -n +11) # Keep 10 binary backups
        if [[ -n "$binary_backups" ]]; then
            echo "$binary_backups" | xargs rm -f
            local removed_count
            removed_count=$(echo "$binary_backups" | wc -l | tr -d ' ')
            log_info "Removed $removed_count old binary backup(s)"
        fi
    fi
    
    log_success "Backup cleanup completed"
}

# Backup existing configuration if present
backup_config() {
    local installation_type="$1"
    
    # Create config directory if it doesn't exist
    mkdir -p "$CONFIG_DIR"

    if [[ -f "$CONFIG_FILE" ]]; then
        local timestamp
        timestamp=$(date +%Y%m%d-%H%M%S)
        local backup_file="${CONFIG_DIR}/config-${timestamp}.toml.backup"

        if [[ "$installation_type" == "update" ]]; then
            log_info "Update detected: Creating configuration backup..."
        else
            log_info "Existing configuration found: Creating backup..."
        fi
        
        if cp "$CONFIG_FILE" "$backup_file"; then
            log_success "Backup created: $backup_file"
        else
            log_warn "Failed to create backup of existing config"
        fi
    fi
}

# Generate destinations configuration based on network selection
generate_destinations() {
    local template_file="${TEMPLATE_DIR_BUNDLE}/${NETWORK}.toml.template"

    # Check if template file exists
    if [[ ! -f "$template_file" ]]; then
        log_error "Template file not found: $template_file"
        log_info "Falling back to default configuration"
        # Fallback to rotsee template
        template_file="${TEMPLATE_DIR_BUNDLE}/rotsee.toml.template"
        if [[ ! -f "$template_file" ]]; then
            log_error "Default template file not found: $template_file"
            log_error "Template directory should be: $TEMPLATE_DIR_BUNDLE"
            exit 1
        fi
    fi

    # Read and output template content
    cat "$template_file"
}


# Generate the configuration file
generate_config() {
    local installation_type="$1"
    
    log_info "Generating configuration file..."

    # Save previous config file for rollback if it exists
    if [[ -f "$CONFIG_FILE" ]]; then
        PREV_CONFIG_FILE="${CONFIG_FILE}.pre-install"
        cp "$CONFIG_FILE" "$PREV_CONFIG_FILE"
        add_rollback_step "rollback_restore_config"
    else
        add_rollback_step "rollback_remove_config"
    fi

    # For updates, check if we should preserve existing config
    if [[ "$installation_type" == "update" ]] && [[ -f "$CONFIG_FILE" ]]; then
        log_info "Update detected: Checking if configuration should be preserved..."
        
        # Check if existing config has user modifications
        local existing_network=""
        if grep -q "# Network:" "$CONFIG_FILE" 2>/dev/null; then
            existing_network=$(grep "# Network:" "$CONFIG_FILE" | sed 's/.*Network: //' | tr -d ' ')
        fi
        
        # Check if config version is compatible
        local existing_version=""
        if grep -q "version = " "$CONFIG_FILE" 2>/dev/null; then
            existing_version=$(grep "version = " "$CONFIG_FILE" | sed 's/version = //' | tr -d ' ')
        fi
        
        # If network matches and version is compatible, preserve existing config
        if [[ "$existing_network" == "$NETWORK" ]] && [[ "$existing_version" == "4" ]]; then
            log_info "Preserving existing configuration (network: $existing_network, version: $existing_version)"
            log_success "Configuration preserved during update"
            return 0
        else
            log_info "Configuration needs update (network: $existing_network->$NETWORK, version: $existing_version->4)"
        fi
    fi

    # Generate new configuration
    local destinations
    destinations=$(generate_destinations)

    # Write configuration file
    cat > "$CONFIG_FILE" <<EOF
###
# Gnosis VPN service configuration file
#
# On unix the default config path is \`/etc/gnosisvpn/config.toml\`
# However you can override this by using \`GNOSISVPN_CONFIG_PATH\` env var
#
# Generated by installer on $(date)
# Network: $NETWORK
# Installation type: $installation_type
###

version = 4

${destinations}
EOF

    if [[ -f "$CONFIG_FILE" ]]; then
        if [[ "$installation_type" == "update" ]]; then
            log_success "Configuration file updated: $CONFIG_FILE"
        else
            log_success "Configuration file created: $CONFIG_FILE"
        fi
    else
        log_error "Failed to create configuration file"
        exit 1
    fi
}

# Update binaries incrementally (only if changed)
update_binaries() {
    local installation_type="$1"
    
    log_info "Updating binaries..."
    
    # For fresh installations, just copy all binaries
    if [[ "$installation_type" == "fresh" ]]; then
        log_info "Fresh installation: Installing all binaries..."
        
        # Install gnosis_vpn
        if [[ -f "${2}/usr/local/bin/gnosis_vpn" ]]; then
            cp "${2}/usr/local/bin/gnosis_vpn" "$BIN_DIR/gnosis_vpn"
            chmod 755 "$BIN_DIR/gnosis_vpn"
            chown root:wheel "$BIN_DIR/gnosis_vpn" 2>/dev/null || true
            log_success "Installed gnosis_vpn"
        fi
        
        # Install gnosis_vpn-ctl
        if [[ -f "${2}/usr/local/bin/gnosis_vpn-ctl" ]]; then
            cp "${2}/usr/local/bin/gnosis_vpn-ctl" "$BIN_DIR/gnosis_vpn-ctl"
            chmod 755 "$BIN_DIR/gnosis_vpn-ctl"
            chown root:wheel "$BIN_DIR/gnosis_vpn-ctl" 2>/dev/null || true
            log_success "Installed gnosis_vpn-ctl"
        fi
        
    else
        # For updates, check each binary individually
        log_info "Update installation: Checking which binaries need updates..."
        
        local updates_made=0
        
        # Update gnosis_vpn if needed
        if [[ -f "${2}/usr/local/bin/gnosis_vpn" ]]; then
            if update_binary_if_needed "gnosis_vpn" "${2}/usr/local/bin/gnosis_vpn"; then
                updates_made=$((updates_made + 1))
            fi
        fi
        
        # Update gnosis_vpn-ctl if needed
        if [[ -f "${2}/usr/local/bin/gnosis_vpn-ctl" ]]; then
            if update_binary_if_needed "gnosis_vpn-ctl" "${2}/usr/local/bin/gnosis_vpn-ctl"; then
                updates_made=$((updates_made + 1))
            fi
        fi
        
        if [[ $updates_made -gt 0 ]]; then
            log_success "Updated $updates_made binary(ies)"
        else
            log_info "All binaries are up to date"
        fi
    fi
}

# Set proper file permissions
set_permissions() {
    log_info "Setting file permissions..."

    chmod 755 "$BIN_DIR/gnosis_vpn" 2>/dev/null || true
    chmod 755 "$BIN_DIR/gnosis_vpn-ctl" 2>/dev/null || true
    chmod 644 "$CONFIG_FILE" 2>/dev/null || true

    # Make the config directory readable by all users
    chmod 755 "$CONFIG_DIR" 2>/dev/null || true

    # Set ownership to root:wheel
    chown root:wheel "$BIN_DIR/gnosis_vpn" 2>/dev/null || true
    chown root:wheel "$BIN_DIR/gnosis_vpn-ctl" 2>/dev/null || true
    chown root:wheel "$CONFIG_FILE" 2>/dev/null || true
    chown root:wheel "$CONFIG_DIR" 2>/dev/null || true

    log_success "Permissions and ownership set"
}

# Verify binaries are in PATH
verify_path() {
    log_info "Verifying binaries are in PATH..."

    # Binaries are already in /usr/local/bin which is typically in PATH
    log_success "Binaries installed to $BIN_DIR (typically in PATH)"
    log_info "You should be able to run 'gnosis_vpn' and 'gnosis_vpn-ctl' from anywhere"
}

# Verify installation
verify_installation() {
    log_info "Verifying installation..."

    local errors=0

    if [[ ! -x "$BIN_DIR/gnosis_vpn" ]]; then
        log_error "gnosis_vpn binary not found or not executable"
        errors=$((errors + 1))
    fi

    if [[ ! -x "$BIN_DIR/gnosis_vpn-ctl" ]]; then
        log_error "gnosis_vpn-ctl binary not found or not executable"
        errors=$((errors + 1))
    fi

    if [[ ! -f "$CONFIG_FILE" ]]; then
        log_error "Configuration file not found"
        errors=$((errors + 1))
    fi

    if [[ $errors -gt 0 ]]; then
        log_error "Installation verification failed with $errors error(s)"
        exit 1
    fi

    log_success "Installation verified successfully"
}

# Print installation summary
print_summary() {
    local installation_type="$1"
    
    if [[ "$installation_type" == "update" ]]; then
        log_section "Update Summary"
        log_info "Installation type: Update"
    else
        log_section "Installation Summary"
        log_info "Installation type: Fresh installation"
    fi
    
    log_info "Version: $INSTALLER_VERSION"
    log_info "Binary directory: $BIN_DIR"
    log_info "Configuration file: $CONFIG_FILE"
    log_info "Version file: $VERSION_FILE"
    log_info "Network: $NETWORK"
    echo ""
    log_info "Installed binaries:"
    ls -lh "$BIN_DIR"/gnosis_vpn* 2>/dev/null || true
    echo ""
    
    # Show backup files if they exist
    if ls "$CONFIG_DIR"/*.backup 2>/dev/null | head -1 >/dev/null; then
        echo ""
        log_info "Configuration backups:"
        ls -lh "$CONFIG_DIR"/*.backup 2>/dev/null || true
    fi
    
    if ls "$BIN_DIR"/*.backup-* 2>/dev/null | head -1 >/dev/null; then
        echo ""
        log_info "Binary backups:"
        ls -lh "$BIN_DIR"/*.backup-* 2>/dev/null || true
    fi
    
    echo ""
    log_info "To get started:"
    log_info "  1. sudo gnosis_vpn -c $CONFIG_FILE"
    log_info "  2. gnosis_vpn-ctl status"
    echo ""
    log_info "Management commands:"
    log_info "  gnosis-vpn-manager status   # Show installation status"
    log_info "  gnosis-vpn-manager backups  # List backup files"
    log_info "  gnosis-vpn-manager version  # Show installed version"
    echo ""
    log_info "Log file: $INSTALLER_LOG_FILE"
    
    if [[ "$installation_type" == "update" ]]; then
        log_success "Update completed successfully!"
    else
        log_success "Installation completed successfully!"
    fi
}

# Main execution
main() {
    # Determine installation type (fresh vs update)
    local installation_type
    installation_type=$(check_previous_installation)
    
    log_section "Installation Type: $installation_type"
    
    # Backup existing configuration
    backup_config "$installation_type"
    
    # Update binaries (incrementally for updates, full for fresh installs)
    update_binaries "$installation_type" "$2"
    
    # Install management script
    if [[ -f "${SCRIPT_DIR}/manage-installation.sh" ]]; then
        cp "${SCRIPT_DIR}/manage-installation.sh" "$BIN_DIR/gnosis-vpn-manager"
        chmod 755 "$BIN_DIR/gnosis-vpn-manager"
        chown root:wheel "$BIN_DIR/gnosis-vpn-manager" 2>/dev/null || true
        log_success "Installed management script: gnosis-vpn-manager"
    fi
    
    # Generate or update configuration
    generate_config "$installation_type"
    
    # Set proper permissions
    set_permissions
    
    # Save version information
    save_version_info
    
    # Clean up old backup files
    cleanup_old_backups
    
    # Verify installation
    verify_path
    verify_installation
    
    # Print summary
    print_summary "$installation_type"

    # Disable rollback after successful completion
    disable_rollback

    # Log script completion
    log_script_end "success"
}

# Execute main function
main

exit 0
